#!/usr/bin/env bash

set -Ceuo pipefail
trap exit ERR

# ============================================================================
# Constants
# ============================================================================
declare -r SCRIPT_NAME=$(basename "${0}")
declare -r VERSION="5.3.0"
declare -r WORK_DIR=$(dirname $(readlink -f "${SCRIPT_NAME}"))
declare -r DOT_HOME="${HOME}/.dots"

# Required packages
declare -ra REQUIRED_PACKAGES=("vim" "zsh" "git" "tmux" "cmake")

# Installation flags and Mode
declare -a TARGETS=()
declare COMMAND_MODE="help" # Default mode

# ============================================================================
# Color Configuration
# ============================================================================

detect_terminal_theme() {
  if [ -n "${COLORFGBG:-}" ]; then
    local bg_color="${COLORFGBG##*;}"
    if [ "${bg_color}" -ge 0 ] 2>/dev/null && [ "${bg_color}" -le 6 ]; then
      echo "dark"
      return
    elif [ "${bg_color}" -ge 7 ] 2>/dev/null; then
      echo "light"
      return
    fi
  fi

  case "${TERM_PROGRAM:-}" in
    "iTerm.app"|"Apple_Terminal")
      echo "dark"
      return
      ;;
  esac

  if [ -n "${WT_SESSION:-}" ]; then
    echo "dark"
    return
  fi

  echo "dark"
}

declare THEME_MODE="${THEME_MODE:-$(detect_terminal_theme)}"

# ============================================================================
# Logging Functions
# ============================================================================

declare -r RESET="\033[0m"
declare -r BOLD="\033[1m"

if [ "${THEME_MODE}" = "light" ]; then
  declare -r FG_RED="\033[31m"
  declare -r FG_GREEN="\033[32m"
  declare -r FG_YELLOW="\033[33m"
  declare -r FG_CYAN="\033[36m"
  declare -r FG_GRAY="\033[90m"
else
  declare -r FG_RED="\033[91m"
  declare -r FG_GREEN="\033[92m"
  declare -r FG_YELLOW="\033[93m"
  declare -r FG_CYAN="\033[96m"
  declare -r FG_GRAY="\033[37m"
fi

log_error() {
  echo -e "${FG_RED}ERROR:${RESET} $*" >&2
}

log_warn() {
  echo -e "${FG_YELLOW}WARNING:${RESET} $*"
}

log_success() {
  echo -e "${FG_GREEN}OK:${RESET} $*"
}

log_info() {
  echo -e "${FG_CYAN}INFO:${RESET} $*"
}

log_skip() {
  echo -e "${FG_GRAY}SKIP:${RESET} $*"
}

prompt_continue() {
  echo -e "${FG_YELLOW}Press [Enter] to ${*}...${RESET}"
  read -r KEY
}

# ============================================================================
# System Check Functions
# ============================================================================

command_exists() {
  type "${1}" >/dev/null 2>&1
}

check_os_compatibility() {
  if [[ ! "${OSTYPE}" =~ 'linux' ]] && [[ ! "${OSTYPE}" =~ 'darwin' ]]; then
    log_error "This script is designed to run on Linux. Your current operating system appears to be ${OSTYPE}."
    prompt_continue "exit"
    return 2>&- || exit
  fi

  if ! command_exists git; then
    log_error "'git' is NOT installed on your computer. Please install it to continue."
    prompt_continue "exit"
    return 2>&- || exit
  fi
}

# ============================================================================
# Package Manager Functions
# ============================================================================

detect_package_manager() {
  if command_exists apt-get; then
    echo "apt-get"
  elif command_exists dnf; then
    echo "dnf"
  elif command_exists yum; then
    echo "yum"
  elif command_exists pacman; then
    echo "pacman"
  else
    echo ""
  fi
}

install_packages_apt() {
  log_info "Detected Debian/Ubuntu"
  sudo apt-get update
  sudo apt-get -y install vim zsh git tmux cmake build-essential
}

install_packages_dnf() {
  log_info "Detected Fedora"
  sudo dnf -y groupinstall "Development Tools"
  sudo dnf -y install vim zsh git tmux cmake kernel-devel kernel-headers
}

install_packages_yum() {
  log_info "Detected RHEL/CentOS"
  sudo yum -y groupinstall "Development Tools"
  sudo yum -y install vim zsh git tmux cmake kernel-devel kernel-headers
}

install_packages_pacman() {
  log_info "Detected Arch Linux"
  sudo pacman -S --needed vim zsh git tmux cmake base-devel
}

install_required_packages() {
  local all_installed=true
  for pkg in "${REQUIRED_PACKAGES[@]}"; do
    if ! command_exists "${pkg}"; then
      all_installed=false
      break
    fi
  done

  if ${all_installed}; then
    log_skip "All required packages already installed"
    return 0
  fi

  log_info "Installing packages"
  local pkg_manager=$(detect_package_manager)

  case "${pkg_manager}" in
    apt-get) install_packages_apt ;;
    dnf)     install_packages_dnf ;;
    yum)     install_packages_yum ;;
    pacman)  install_packages_pacman ;;
    *)
      log_error "No supported package manager found"
      echo ""
      echo "Please install manually: vim, zsh, git, tmux, cmake, build-essential"
      echo ""
      return 2>&- || exit
      ;;
  esac

  log_success "Package installation completed"
}

# ============================================================================
# SSH Configuration Functions
# ============================================================================

setup_ssh_directory() {
  if [ ! -d ~/.ssh ]; then
    log_info "Creating ~/.ssh directory"
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
  else
    log_skip "SSH directory exists"
  fi
}

generate_github_ssh_key() {
  if [ ! -f ~/.ssh/github ]; then
    log_info "Generating SSH key"
    ssh-keygen -t ed25519 -b 521 -C '' -N '' -f ~/.ssh/github
  else
    log_skip "SSH key exists"
  fi
}

configure_github_ssh() {
  if ! grep -qE "^[[:space:]]*[Hh]ost[[:space:]]+github([[:space:]]|$)" ~/.ssh/config 2>/dev/null; then
    log_info "Adding SSH configuration"
    cat << EOF > ~/.ssh/config
host github github.com
  Hostname github.com
  IdentityFile ~/.ssh/github
  User git
EOF
    chmod 600 ~/.ssh/config
  else
    log_skip "SSH config exists"
  fi
}

is_github_ssh_configured() {
  local config_file="${HOME}/.ssh/config"
  local key_file="${HOME}/.ssh/github"

  if [[ ! -f "${config_file}" ]]; then return 1; fi
  if ! grep -qE "^[[:space:]]*[Hh]ost[[:space:]]+github([[:space:]]|$)" "${config_file}"; then return 1; fi
  if [[ ! -f "${key_file}" ]]; then return 1; fi

  return 0
}

display_github_key_registration_prompt() {
  echo ""
  echo "GitHub SSH public key:"
  echo "------------------------------------------------------------"
  cat ~/.ssh/github.pub
  echo "------------------------------------------------------------"
  echo ""
  echo "Steps:"
  echo "  1. Visit https://github.com/settings/ssh/new"
  echo "  2. Register the above public key"
  echo ""
  read -p "Press [Enter] when complete..." KEY
}

test_github_connection() {
  log_info "Testing GitHub connection"
  local ssh_output
  ssh_output=$(ssh -o StrictHostKeyChecking=no -T git@github.com 2>&1 || true)

  if echo "${ssh_output}" | grep -q "successfully authenticated"; then
    log_success "GitHub SSH verified"
    return 0
  else
    log_warn "GitHub SSH connection failed"
    echo ""
    echo "Command output:"
    echo "${ssh_output}"
    echo ""
    return 1
  fi
}

setup_github_ssh() {
  local retry_count="${1:-0}"
  local max_retries=3

  if [ "${retry_count}" -eq 0 ]; then
    setup_ssh_directory
  fi

  if is_github_ssh_configured; then
    log_skip "GitHub SSH already configured"
    return 0
  fi

  log_info "Setting up GitHub SSH"

  if [ "${retry_count}" -eq 0 ]; then
    generate_github_ssh_key
    configure_github_ssh
    display_github_key_registration_prompt
  fi

  if test_github_connection; then
    return 0
  fi

  if [ "${retry_count}" -ge "${max_retries}" ]; then
    log_error "Maximum retry attempts (${max_retries}) reached"
    return 1
  fi

  local next_retry=$((retry_count + 1))
  echo -n "Retry connection test? (y/N): "
  read -r yn

  case "${yn}" in
    [yY]|[yY][eE][sS])
      echo ""
      log_info "Retrying (attempt ${next_retry}/${max_retries})..."
      setup_github_ssh "${next_retry}"
      return $?
      ;;
    *)
      log_warn "Setup aborted"
      return 1
      ;;
  esac
}

# ============================================================================
# Helper Functions for File Operations
# ============================================================================

create_symlink() {
  local source="${1}"
  local target="${2}"

  if [ -L "${target}" ]; then
    local current_source=$(readlink -f "${target}")
    local expected_source=$(readlink -f "${source}")
    if [ "${current_source}" = "${expected_source}" ]; then
      log_skip "${target} exists"
      return 0
    else
      log_warn "updating ${target}"
      rm "${target}"
    fi
  elif [ -e "${target}" ]; then
    log_error "${target} exists as regular file"
    echo "  Please backup and remove it manually"
    return 1
  fi

  ln -s "${source}" "${target}"
  log_success "${target} -> ${source}"
}

remove_symlink() {
  local target="${1}"

  if [ -e "${target}" ] || [ -L "${target}" ]; then
    rm -rf "${target}"
    log_success "Removed ${target}"
  else
    log_skip "${target} not found"
  fi
}

ensure_directory() {
  local dirpath="${1}"
  if [ ! -d "${dirpath}" ]; then
    mkdir -p "${dirpath}"
    log_success "created ${dirpath}"
  else
    log_skip "${dirpath} exists"
  fi
}

# ============================================================================
# Dotfile Setup Functions (Install)
# ============================================================================

setup_bash() {
  echo "Setting up Bash..."
  ensure_directory "${HOME}/.cache/bash"
  create_symlink "${DOT_HOME}/bash/bash_profile" "${HOME}/.bash_profile"
  create_symlink "${DOT_HOME}/bash/bashrc"       "${HOME}/.bashrc"
  create_symlink "${DOT_HOME}/bash"             "${HOME}/.bash"
  create_symlink "${DOT_HOME}/scripts"           "${HOME}/.scripts.d"
}

setup_fish() {
  echo "Setting up Fish..."
  ensure_directory "${HOME}/.config/fish"
  create_symlink "${DOT_HOME}/fish/config.fish"  "${HOME}/.config/fish/config.fish"
}

setup_ssh() {
  echo "Setting up SSH..."
  ensure_directory "${HOME}/.ssh/pub"
}

setup_tmux() {
  echo "Setting up Tmux..."
  local plugin_dir="${DOT_HOME}/tmux/vendor"
  local plugin_path="${plugin_dir}/tmux-mem-cpu-load"

  if [ ! -d "${plugin_path}" ]; then
    log_info "Installing tmux plugin"
    if ! command_exists cmake; then
      log_error "'cmake' is NOT installed"
    else
      local plugin_repo="https://github.com/thewtex/tmux-mem-cpu-load"
      mkdir -p "${plugin_dir}"
      cd "${plugin_dir}"
      if git clone "${plugin_repo}" 2>/dev/null; then
        cd tmux-mem-cpu-load
        if cmake . && make && sudo make install; then
          log_success "Tmux plugin installed"
        else
          log_error "Tmux plugin build failed"
        fi
        cd "${DOT_HOME}"
      fi
    fi
  else
    log_skip "Tmux plugin already installed"
  fi

  create_symlink "${DOT_HOME}/tmux/tmux.conf" "${HOME}/.tmux.conf"
}

setup_vim() {
  echo "Setting up Vim..."
  ensure_directory "${HOME}/.vim"
  create_symlink "${DOT_HOME}/vim/vimrc" "${HOME}/.vimrc"
  create_symlink "${DOT_HOME}/vim/rc"    "${HOME}/.vim/rc"
}

setup_zsh() {
  echo "Setting up Zsh..."
  ensure_directory "${HOME}/.cache/zsh"
  create_symlink "${DOT_HOME}/zsh/zshenv" "${HOME}/.zshenv"
  create_symlink "${DOT_HOME}/zsh"       "${HOME}/.zsh"
  create_symlink "${DOT_HOME}/scripts"    "${HOME}/.scripts.d"

  local syntax_dir="${HOME}/.syntax"
  local syntax_repo="https://github.com/zsh-users/zsh-syntax-highlighting"

  if [ -d "${syntax_dir}/.git" ]; then
    log_info "Updating zsh-syntax-highlighting"
    cd "${syntax_dir}"
    git pull >/dev/null 2>&1 || log_warn "Failed to update syntax highlighting"
    cd "${HOME}"
  else
    if [ -d "${syntax_dir}" ]; then rm -rf "${syntax_dir}"; fi
    log_info "Cloning zsh-syntax-highlighting"
    git clone "${syntax_repo}" "${syntax_dir}" >/dev/null 2>&1 || log_warn "Failed to clone syntax highlighting"
  fi
}

# ============================================================================
# Dotfile Removal Functions (Uninstall)
# ============================================================================

remove_bash() {
  echo "Removing Bash configuration..."
  remove_symlink "${HOME}/.bash_profile"
  remove_symlink "${HOME}/.bashrc"
  remove_symlink "${HOME}/.bash"
  remove_symlink "${HOME}/.scripts.d"
}

remove_fish() {
  echo "Removing Fish configuration..."
  remove_symlink "${HOME}/.config/fish/config.fish"
}

remove_ssh() {
  echo "Removing SSH configuration links..."
  log_skip "Skipping SSH directory removal to prevent data loss"
}

remove_tmux() {
  echo "Removing Tmux configuration..."
  remove_symlink "${HOME}/.tmux.conf"
}

remove_vim() {
  echo "Removing Vim configuration..."
  remove_symlink "${HOME}/.vimrc"
  remove_symlink "${HOME}/.vim/rc"
}

remove_zsh() {
  echo "Removing Zsh configuration..."
  remove_symlink "${HOME}/.zshenv"
  remove_symlink "${HOME}/.zsh"
  remove_symlink "${HOME}/.scripts.d"

  if [ -d "${HOME}/.syntax" ]; then
    rm -rf "${HOME}/.syntax"
    log_success "Removed ${HOME}/.syntax"
  fi
}

# ============================================================================
# Core Logic
# ============================================================================

initialize_dotfiles_repo() {
  if [ ! -e "${DOT_HOME}" ]; then
    log_info "Copying dotfiles to ${DOT_HOME}"
    cp -r "${WORK_DIR}" "${DOT_HOME}"
    log_success "Dotfiles copied"
  else
    log_skip "Dotfiles directory exists"
  fi
}

setup_gitconfig() {
  local source="${DOT_HOME}/.gitconfig"
  local target="${HOME}/.gitconfig"
  if [ ! -e "${source}" ]; then
    log_error "'.gitconfig' not found in ${DOT_HOME}"
    return 1
  fi
  if [ ! -e "${target}" ]; then
    cp "${source}" "${target}"
    log_success "Copied .gitconfig"
  else
    log_skip ".gitconfig exists"
  fi
}

process_dotfile() {
  local type="${1}"
  local action="${2}"

  if [ "${action}" == "install" ]; then
    case "${type}" in
      bash) setup_bash ;;
      fish) setup_fish ;;
      ssh)  setup_ssh ;;
      tmux) setup_tmux ;;
      vim)  setup_vim ;;
      zsh)  setup_zsh ;;
      *)    log_warn "Unknown dotfile type: ${type}" ;;
    esac
  elif [ "${action}" == "remove" ]; then
    case "${type}" in
      bash) remove_bash ;;
      fish) remove_fish ;;
      ssh)  remove_ssh ;;
      tmux) remove_tmux ;;
      vim)  remove_vim ;;
      zsh)  remove_zsh ;;
      *)    log_warn "Unknown dotfile type: ${type}" ;;
    esac
  fi
}

# ============================================================================
# Main Routines
# ============================================================================

run_init() {
  install_required_packages
  setup_github_ssh
}

run_install() {
  initialize_dotfiles_repo
  setup_gitconfig

  for target in "${TARGETS[@]}"; do
    if [ -n "${target}" ]; then
      process_dotfile "${target}" "install"
    fi
  done

  log_success "Installation completed"
}

run_remove() {
  for target in "${TARGETS[@]}"; do
    if [ -n "${target}" ]; then
      process_dotfile "${target}" "remove"
    fi
  done

  log_success "Removal completed"
}

# ============================================================================
# Argument Parsing
# ============================================================================

usage() {
  echo "Usage: ./${SCRIPT_NAME} [COMMAND] [OPTIONS] [TARGETS...]"
  echo ""
  echo "COMMANDS:"
  echo "  init    | --init          : Initialize environment (packages & SSH)"
  echo "  install | -i | --install  : Install dotfiles (create symlinks) [Default]"
  echo "  remove  | -r | --remove   : Remove dotfiles (delete symlinks)"
  echo "  help    | -h | --help     : Show this help"
  echo "  version | -v | --version  : Show version"
  echo ""
  echo "TARGETS:"
  echo "  all     | -a | --all"
  echo "  bash    | --bash"
  echo "  fish    | --fish"
  echo "  ssh     | --ssh"
  echo "  tmux    | --tmux"
  echo "  vim     | --vim"
  echo "  zsh     | --zsh"
  echo ""
  echo "EXAMPLES:"
  echo "  ./${SCRIPT_NAME} init"
  echo "  ./${SCRIPT_NAME} install zsh vim"
  echo "  ./${SCRIPT_NAME} -i --all"
  echo "  ./${SCRIPT_NAME} remove all"
  echo "  ./${SCRIPT_NAME} -r tmux"
}

parse_arguments() {
  if [ $# -eq 0 ]; then
    TARGETS=("ssh" "vim" "zsh")
    return
  fi

  # 1. Determine Command Mode from the first argument
  local first_arg="${1}"

  case "${first_arg}" in
    'init'|'--init')
      COMMAND_MODE="init"
      shift
      ;;
    'install'|'-i'|'--install')
      COMMAND_MODE="install"
      shift
      ;;
    'remove'|'-r'|'--remove')
      COMMAND_MODE="remove"
      shift
      ;;
    'help'|'-h'|'--help')
      usage
      exit 0
      ;;
    'version'|'-v'|'--version')
      echo "${SCRIPT_NAME} version ${VERSION}"
      exit 0
      ;;
    *)
      usage
      exit 0
      ;;
  esac

  # 2. Parse Targets and Options
  for opt in "${@}"; do
    case "${opt}" in
      '-a'|'--all'|'all')
        TARGETS+=("bash" "ssh" "tmux" "vim" "zsh")
        ;;
      '--bash'|'bash') TARGETS+=("bash") ;;
      '--fish'|'fish') TARGETS+=("fish") ;;
      '--ssh'|'ssh')   TARGETS+=("ssh") ;;
      '--tmux'|'tmux') TARGETS+=("tmux") ;;
      '--vim'|'vim')   TARGETS+=("vim") ;;
      '--zsh'|'zsh')   TARGETS+=("zsh") ;;
      *)
        # Strict validation: If any argument is unknown, show help and exit
        log_error "Invalid option or target: '${opt}'"
        echo ""
        usage
        exit 1
        ;;
    esac
  done

  # Default targets if none specified (only for install/remove modes)
  if [ ${#TARGETS[@]} -eq 0 ] && [ "${COMMAND_MODE}" != "init" ]; then
     log_warn "No targets specified. Using defaults: ssh, vim, zsh"
     TARGETS=("ssh" "vim" "zsh")
  fi
}

# ============================================================================
# Entry Point
# ============================================================================

check_os_compatibility
parse_arguments "${@}"

case "${COMMAND_MODE}" in
  init)
    run_init
    ;;
  install)
    run_install
    ;;
  remove)
    run_remove
    ;;
  *)
    usage
    ;;
esac
